import { IExecSyncResult } from 'azure-pipelines-task-lib/toolrunner';
export interface Resource {
    name: string;
    type: string;
    isStrategyRollingUpdate?: boolean;
}
export declare class Kubectl {
    private kubectlPath;
    private namespace;
    private ignoreSSLErrors;
    constructor(kubectlPath: string, namespace?: string, ignoreSSLErrors?: boolean);
    apply(configurationPaths: string | string[]): IExecSyncResult;
    annotate(resourceType: string, resourceName: string, annotations: string[], overwrite?: boolean): IExecSyncResult;
    annotateFiles(files: string | string[], annotations: string[], overwrite?: boolean): IExecSyncResult;
    createDockerSecret(secretName: string, registryServer: string, userName: string, password: string, email: string, force?: boolean): IExecSyncResult;
    createGenericSecret(secretName: string, args: string, force?: boolean): IExecSyncResult;
    describe(resourceType: string, resourceName: string, silent?: boolean): IExecSyncResult;
    getNewReplicaSet(deployment: string): string;
    getAllPods(): IExecSyncResult;
    getClusterInfo(): IExecSyncResult;
    checkRolloutStatus(resourceType: string, name: string, timeoutInSeconds?: string): IExecSyncResult;
    getResource(resourceType: string, name: string): IExecSyncResult;
    getResources(applyOutput: string, filterResourceTypes: string[]): Resource[];
    scale(resourceType: string, resourceName: string, replicas: any): IExecSyncResult;
    patch(resourceType: string, resourceName: string, patch: string, strategy: any): IExecSyncResult;
    delete(args: string): IExecSyncResult;
    executeCommand(customCommand: string, args?: string, silent?: boolean): IExecSyncResult;
    private execute;
    private createInlineArray;
    private deleteSecret;
    private displayKubectlVersion;
}
