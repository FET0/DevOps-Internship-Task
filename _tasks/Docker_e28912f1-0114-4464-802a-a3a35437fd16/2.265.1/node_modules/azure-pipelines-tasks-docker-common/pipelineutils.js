"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getDefaultLabels = exports.addDefaultLabelArgs = void 0;
const tl = require("azure-pipelines-task-lib/task");
const URL = require("url");
const util = require("util");
const containerUtils = require("./containerimageutils");
function addLabelArgs(command, labels) {
    labels.forEach(label => {
        command.arg(["--label", label]);
    });
}
function addLabel(hostName, labelName, variableName, labels) {
    let labelValue = tl.getVariable(variableName);
    if (labelValue) {
        let label = util.format("%s.image.%s=%s", hostName, labelName, labelValue);
        labels.push(label);
    }
}
function addLabelWithValue(labelName, labelValue, labels) {
    let label = util.format("%s=%s", labelName, labelValue);
    labels.push(label);
}
function addCommonLabels(hostName, labels, addPipelineData) {
    addLabel(hostName, "system.teamfoundationcollectionuri", "SYSTEM_TEAMFOUNDATIONCOLLECTIONURI", labels);
    if (addPipelineData) {
        addLabel(hostName, "system.teamproject", "SYSTEM_TEAMPROJECT", labels);
        addLabel(hostName, "build.repository.name", "BUILD_REPOSITORY_NAME", labels);
    }
}
function addBuildLabels(hostName, labels, addPipelineData) {
    addLabel(hostName, "build.sourceversion", "BUILD_SOURCEVERSION", labels);
    if (addPipelineData) {
        addLabel(hostName, "build.repository.uri", "BUILD_REPOSITORY_URI", labels);
        addLabel(hostName, "build.sourcebranchname", "BUILD_SOURCEBRANCHNAME", labels);
        addLabel(hostName, "build.definitionname", "BUILD_DEFINITIONNAME", labels);
        addLabel(hostName, "build.buildnumber", "BUILD_BUILDNUMBER", labels);
        addLabel(hostName, "build.builduri", "BUILD_BUILDURI", labels);
    }
}
function addReleaseLabels(hostName, labels, addPipelineData) {
    addLabel(hostName, "release.releaseid", "RELEASE_RELEASEID", labels);
    if (addPipelineData) {
        addLabel(hostName, "release.definitionname", "RELEASE_DEFINITIONNAME", labels);
        addLabel(hostName, "release.releaseweburl", "RELEASE_RELEASEWEBURL", labels);
    }
}
function addBaseImageLabels(connection, labels, dockerFilePath) {
    // using getBaseImageDetialsFromDockerFIle method to fetch both image and imagedigest
    const baseImage = containerUtils.getBaseImageDetialsFromDockerFIle(dockerFilePath, connection);
    if (!baseImage.name) {
        return;
    }
    addLabelWithValue("image.base.ref.name", baseImage.name, labels);
    //first check if there is digest passed in Dockerfile
    if (!baseImage.digest) {
        baseImage.digest = containerUtils.getImageDigest(connection, baseImage.name);
    }
    //if there is no digest in Dockerfile, get digest using ImageName:tag
    if (baseImage.digest) {
        addLabelWithValue("image.base.digest", baseImage.digest, labels);
    }
}
function getReverseDNSName() {
    // Hostname part of URL used as prefix for labels.
    // it is safe to use url.parse on SYSTEM_TEAMFOUNDATIONCOLLECTIONURI here.
    var teamFoundationCollectionURI = tl.getVariable("SYSTEM_TEAMFOUNDATIONCOLLECTIONURI");
    if (teamFoundationCollectionURI) {
        var parsedUrl = URL.parse(teamFoundationCollectionURI);
        if (parsedUrl) {
            var hostName = parsedUrl.hostname.split(".").reverse().join(".");
            tl.debug(`Reverse DNS name ${hostName}`);
            return hostName;
        }
    }
    return null;
}
function addDefaultLabelArgs(command) {
    let labels = getDefaultLabels();
    addLabelArgs(command, labels);
}
exports.addDefaultLabelArgs = addDefaultLabelArgs;
function getDefaultLabels(addPipelineData, addBaseImageData, dockerFilePath, connection) {
    let labels = [];
    let hostName = getReverseDNSName();
    if (hostName) {
        addCommonLabels(hostName, labels, addPipelineData);
        let hostType = tl.getVariable("SYSTEM_HOSTTYPE");
        if (hostType.toLowerCase() === "build") {
            addBuildLabels(hostName, labels, addPipelineData);
        }
        else {
            addReleaseLabels(hostName, labels, addPipelineData);
        }
    }
    if (addBaseImageData) {
        try {
            addBaseImageLabels(connection, labels, dockerFilePath);
        }
        catch (error) {
            tl.debug(`An error ocurred getting the base image lables ${error.message}`);
        }
    }
    return labels;
}
exports.getDefaultLabels = getDefaultLabels;
